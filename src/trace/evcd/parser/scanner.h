#ifndef _SCANNER_H
#define _SCANNER_H

// Flex expects the signature of yylex to be defined in the macro YY_DECL, and
// the C++ parser expects it to be declared. We can factor both as follows.

#ifndef YY_DECL

#define YY_DECL int evcd::Scanner::lex( evcd::Parser::semantic_type* yylval, evcd::Parser::location_type* yylloc)
#endif

#ifndef __FLEX_LEXER_H
#define yyFlexLexer EvcdFlexLexer
#include "FlexLexer.h"
#undef yyFlexLexer
#endif

#include "evcd_yacc.hpp"

namespace evcd
{
    class Scanner : public EvcdFlexLexer
    {
        public:
            /** Create a new scanner object. The streams arg_yyin and arg_yyout default
             * to cin and cout, but that assignment is only made when initializing in
             * yylex(). */
            Scanner( std::istream* arg_yyin = 0, std::ostream* arg_yyout = 0);

            /** Required for virtual functions */
            virtual ~Scanner();

            /** This is the main lexing function. It is generated by flex according to
             * the macro declaration YY_DECL above. The generated bison parser then
             * calls this virtual function to fetch new tokens. */
//    virtual Parser::token_type lex(
//    Parser::semantic_type* yylval,
//    Parser::location_type* yylloc
//    );
            virtual int lex( string *yylval, location *yylloc);

            /** Enable debug output (via arg_yyout) if compiled into the scanner. */
            void set_debug     ( bool    b);

            virtual void LexerOutput( const char* buf, int size );

            void comment       ( string* lval, location *yylloc);
            void untilEnd      ( string* lval, location *yylloc);
            int  procIdCode();
            int  prevState;
    };

} // namespace evcd

#endif // EXAMPLE_SCANNER_H
